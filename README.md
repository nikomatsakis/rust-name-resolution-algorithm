This respository contains a prototype for the new name resolution
algorithm I would like to propose (and eventually implement) for Rust.
This algorithm permits macros to be used and imported just like any
other language item. It also fully supports globs and so forth.

In terms of how it feels as a user, everything basically just works,
subject to the following simple rule:

It is always an error to have two names defined in the same scope.
The source of those names doesn't matter: they could have been
imported explicitly or via a glob, generated by a macro, written by
hand etc.

*Note:* This is roughly Rust's current semantics. It is also a
departure from my prior efforts, which gave globs lower
precedence. This is required for the algorithm to support glob
imports of macros. The problem case is when we have a macro found
witha path like `self::a::b!`. Suppose that the module has a `use
foo::*;` which was the origin of the module `a`. But then the
macro generates a module `b` as well. Now we are in a quandry: to
load the macro in the first place, we had to use the `b` from the
glob, but that `b` was shadowed by code that the macro
generated. There are various ways to resolve this, but banning
duplicates seems like the simplest and easiest to understand
solution. Some other possibilities:
- macros cannot be imported through globs; seems like a shame, I might have a whole
  family of macros I would like to make use of.
- macro-generated names have lowest precedence of all; complex
  and probably not a solution. I suspect you can just concoct
  examples of macro-generating-macros that get into the same
  situation.

The prototype does also make `use` statements behave more like regular
items. In particular, a `use` statement in a parent module can be
referenced by child modules (iow, a `use` is the same as a `pub use`,
but that it is not public outside the module). This is not how Rust
works today but is largely backwards compatible I thik. It is also
probably something we could change in the algorithm if we wanted.

